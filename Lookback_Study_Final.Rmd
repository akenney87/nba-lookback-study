
---
title: "NBA Per-36 Projection Pipeline (Steps 1–4)"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
params:
  per36_csv: "data/Per36Minutes.csv"
  career_csv: "data/PlayerCareerInfo.csv"
  target_season: 2026
editor_options:
  chunk_output_type: console
---

```{r setup}
# Fast, reproducible, and quiet setup
knitr::opts_chunk$set(
  echo = TRUE, message = FALSE, warning = FALSE,
  cache = TRUE, cache.comments = FALSE
)

suppressPackageStartupMessages({
  library(dplyr)
  library(readr)
  library(tidyr)
  library(stringr)
  library(purrr)
  library(broom)
  library(janitor)
  library(here)
  library(dplyr)
  library(ggplot2)
  library(ggrepel)
  library(scales)
  library(rlang)
  library(ggtext)
})

knitr::opts_knit$set(root.dir = here::here())

set.seed(1)

if (!exists("params")) {
params <- list(
per36_csv = "data/Per36Minutes.csv",
career_csv = "data/PlayerCareerInfo.csv"
)
}

stat_labs <- c(
pts_per_36_min = "PTS/36",
trb_per_36_min = "TRB/36",
ast_per_36_min = "AST/36",
stl_per_36_min = "STL/36",
blk_per_36_min = "BLK/36",
x3p_per_36_min = "3PM/36",
fg_percent = "FG%",
ft_percent = "FT%",
tov_per_36_min = "TOV/36"
)

```

```{r helpers}
# Light helpers used in multiple chunks
wavg <- function(x, w) {
  s <- sum(w, na.rm = TRUE)
  ifelse(s > 0, sum(x * w, na.rm = TRUE) / s, NA_real_)
}

read_data <- function(rel_path) {
stopifnot(is.character(rel_path), length(rel_path) == 1)
fp <- here::here(rel_path)
if (!file.exists(fp)) stop("Missing data file: ", fp, call. = FALSE)
readr::read_csv(fp, show_col_types = FALSE)
}
```

``` {r load and robust season collapse}
raw <- read_data(params$per36_csv) %>%
  janitor::clean_names()   # gives snake_case like fg_per_36_min, ft_percent, etc.

tot_tags <- c("tot","2tm","3tm","4tm","5tm","6tm","7tm")

# detect team column if present (some sources use 'team', others 'tm')
team_col <- dplyr::first(intersect(c("team","tm"), names(raw)))
if (is.na(team_col)) team_col <- NULL

by_player_season <- raw %>%
  dplyr::group_by(player_id, season) %>%
  dplyr::summarise({
    df <- dplyr::cur_data_all()

    # Combined row detection (prefer team label, fallback to G equality)
    if (!is.null(team_col)) {
      is_combined <- tolower(df[[team_col]]) %in% tot_tags
    } else {
      g_sum <- sum(df$g, na.rm = TRUE)
      is_combined <- abs(df$g - (g_sum - df$g)) < 1e-9
    }
    team_rows <- !is_combined
    df_team <- if (any(team_rows, na.rm = TRUE)) df[team_rows, , drop = FALSE] else df

    # Minutes & games totals (prefer combined row if it exists and is consistent)
    mp_sum <- sum(df_team$mp, na.rm = TRUE)
    if (any(is_combined, na.rm = TRUE)) {
      g_val  <- suppressWarnings(max(df$g[is_combined],  na.rm = TRUE))
      mp_comb <- suppressWarnings(max(df$mp[is_combined], na.rm = TRUE))
      mp_val <- if (!is.na(mp_comb) && mp_comb >= 0.95 * mp_sum) mp_comb else mp_sum
    } else {
      g_val  <- suppressWarnings(max(df$g,  na.rm = TRUE))
      mp_val <- mp_sum
    }

    # Recompute % from totals; minutes-weight per-36 across team stints
    fgm_tot <- sum(df_team$fg_per_36_min  * df_team$mp / 36, na.rm = TRUE)
    fga_tot <- sum(df_team$fga_per_36_min * df_team$mp / 36, na.rm = TRUE)
    ftm_tot <- sum(df_team$ft_per_36_min  * df_team$mp / 36, na.rm = TRUE)
    fta_tot <- sum(df_team$fta_per_36_min * df_team$mp / 36, na.rm = TRUE)

    fg_pct <- ifelse(fga_tot > 0, fgm_tot / fga_tot, NA_real_)
    ft_pct <- ifelse(fta_tot > 0, ftm_tot / fta_tot, NA_real_)

    pts36 <- wavg(df_team$pts_per_36_min, df_team$mp)
    trb36 <- wavg(df_team$trb_per_36_min, df_team$mp)
    ast36 <- wavg(df_team$ast_per_36_min, df_team$mp)
    stl36 <- wavg(df_team$stl_per_36_min, df_team$mp)
    blk36 <- wavg(df_team$blk_per_36_min, df_team$mp)
    x3p36 <- wavg(df_team$x3p_per_36_min, df_team$mp)
    tov36 <- wavg(df_team$tov_per_36_min, df_team$mp)
    fga36 <- wavg(df_team$fga_per_36_min, df_team$mp)
    fta36 <- wavg(df_team$fta_per_36_min, df_team$mp)

    idx_mm <- ifelse(all(is.na(df$mp)), 1L, which.max(df$mp))

    tibble::tibble(
      player = df$player[idx_mm],
      pos    = df$pos[idx_mm],
      g      = g_val,
      mp     = mp_val,
      mpg    = ifelse(g_val > 0, mp_val / g_val, NA_real_),
      fg_percent = fg_pct,
      ft_percent = ft_pct,
      pts_per_36_min = pts36,
      trb_per_36_min = trb36,
      ast_per_36_min = ast36,
      stl_per_36_min = stl36,
      blk_per_36_min = blk36,
      x3p_per_36_min = x3p36,
      tov_per_36_min = tov36,
      fga_per_36_min = fga36,
      fta_per_36_min = fta36
    )
  }, .groups = "drop")
```


```{r filter modeling window}
df_clean <- by_player_season %>%
  filter(season >= 2015, mp >= 1000) %>%
  select(
    player_id, player, pos, season, mp,
    fg_percent, ft_percent,
    pts_per_36_min, trb_per_36_min, ast_per_36_min,
    stl_per_36_min, blk_per_36_min, x3p_per_36_min, tov_per_36_min,
    fga_per_36_min, fta_per_36_min
  )

# Stats we’ll model
stats_vec <- c(
  "pts_per_36_min","trb_per_36_min","ast_per_36_min",
  "stl_per_36_min","blk_per_36_min","x3p_per_36_min",
  "fg_percent","ft_percent","tov_per_36_min"
)
```

### Globals (Evaluation & Plotting)

Before constructing the lagged features and comparing methods, we define a set of global constants used throughout the evaluation and plotting. These include the maximum lookback depth (`k_max`), the sequence of lookback values (`k_grid`), the minutes cutoff for player eligibility, the cutoff season for the training set (`first_train_end`), and the grid of alpha values for exponential weighting.

```{r globals, echo=TRUE}
# Lookback depth used everywhere
k_max  <- 5
k_grid <- 1:k_max

# Minutes rule used by prev_season_ok() and has_full_minutes_k()
minutes_cutoff <- 1000L

# Train/test split for evaluate_rolling() wrappers
first_train_end <- 2018L

# Methods’ hyperparameters (for exponential weighting)
alpha_grid <- c(0.3, 0.4, 0.5, 0.6, 0.7)
```

```{r lookback features and method comparison}
stopifnot(all(c("player_id","season","mp", stats_vec) %in% names(df_clean)))

base <- df_clean %>% dplyr::select(player_id, season, mp, dplyr::all_of(stats_vec))

lagged_list <- lapply(1:k_max, function(i) {
  base %>%
    dplyr::mutate(season = season + i) %>%
    # mp -> mp_L{i}
    dplyr::rename(!!paste0("mp_L", i) := mp) %>%
    # stats -> {stat}_L{i}
    dplyr::rename_with(~ paste0(.x, "_L", i), dplyr::all_of(stats_vec)) %>%
    # keep only player_id, season, mp_L{i}, and the lagged stats
    dplyr::select(
      player_id, season,
      !!rlang::sym(paste0("mp_L", i)),
      dplyr::all_of(paste0(stats_vec, "_L", i))
    )
})

# Start from the actual (unlagged) columns
joined <- base %>% dplyr::select(player_id, season, mp, dplyr::all_of(stats_vec))

# Left-join each lag table
for (lag_tbl in lagged_list) {
  joined <- dplyr::left_join(joined, lag_tbl, by = c("player_id","season"))
}

# Quick sanity check: ensure mp_L1..mp_L5 exist
stopifnot(all(paste0("mp_L", 1:k_max) %in% names(joined)))

# --- 2) Helpers: minutes eligibility + stat availability for a given k ---
has_full_minutes_k <- function(df, k) {
  req <- paste0("mp_L", 1:k)
  df %>%
    dplyr::mutate(.ok_min = dplyr::if_all(dplyr::all_of(req), ~ !is.na(.x) & .x >= minutes_cutoff)) %>%
    dplyr::pull(.ok_min)
}

has_full_stats_k <- function(df, stat, k) {
  req <- paste0(stat, "_L", 1:k)
  df %>%
    dplyr::mutate(.ok_stat = dplyr::if_all(dplyr::all_of(req), ~ !is.na(.x))) %>%
    dplyr::pull(.ok_stat)
}

# Your “skip if previous season < 1000” rule (independent of k)
prev_season_ok <- function(df) {
  if (!("mp_L1" %in% names(df))) return(rep(FALSE, nrow(df)))
  !is.na(df$mp_L1) & df$mp_L1 >= minutes_cutoff
}

# --- 3) Predictors (equal / exponential / linear regression) ---
predict_equal_k <- function(df, stat, k) {
  lag_cols <- paste0(stat, "_L", 1:k)
  df %>%
    dplyr::filter(prev_season_ok(.),
                  has_full_minutes_k(., k),
                  has_full_stats_k(., stat, k)) %>%
    dplyr::mutate(pred_equal = rowMeans(dplyr::across(dplyr::all_of(lag_cols)))) %>%
    dplyr::select(player_id, season, actual = !!rlang::sym(stat), pred_equal)
}

predict_exp_k <- function(df, stat, k, alpha = 0.5) {
  lag_cols <- paste0(stat, "_L", 1:k)
  w <- alpha * (1 - alpha)^(0:(k-1)); w <- w / sum(w)
  df %>%
    dplyr::filter(prev_season_ok(.),
                  has_full_minutes_k(., k),
                  has_full_stats_k(., stat, k)) %>%
    dplyr::mutate(
      pred_exp = as.numeric(as.matrix(dplyr::select(., dplyr::all_of(lag_cols))) %*% w)
    ) %>%
    dplyr::select(player_id, season, actual = !!rlang::sym(stat), pred_exp)
}

fit_and_predict_reg_k <- function(df, stat, k, train_end_season) {
  lag_cols <- paste0(stat, "_L", 1:k)
  d <- df %>%
    dplyr::filter(prev_season_ok(.),
                  has_full_minutes_k(., k),
                  has_full_stats_k(., stat, k)) %>%
    dplyr::select(player_id, season, dplyr::all_of(stat), dplyr::all_of(lag_cols)) %>%
    tidyr::drop_na()
  train <- d %>% dplyr::filter(season <= train_end_season)
  test  <- d %>% dplyr::filter(season == train_end_season + 1)

  empty_out <- tibble::tibble(
    player_id = character(), season = numeric(),
    actual = numeric(), pred_lm = numeric()
  )
  if (nrow(train) == 0 || nrow(test) == 0) return(empty_out)

  form <- stats::as.formula(paste(stat, "~", paste(lag_cols, collapse = " + ")))
  fit  <- stats::lm(form, data = train)
  test %>%
    dplyr::mutate(pred_lm = stats::predict(fit, newdata = test)) %>%
    dplyr::select(player_id, season, actual = !!rlang::sym(stat), pred_lm)
}

# --- 4) Rolling (walk-forward) evaluation ---
evaluate_rolling <- function(df_joined, stat, k, method = c("equal","exp","lm"),
                             alpha = 0.5, first_train_end = 2018,
                             last_test_season = max(df_joined$season, na.rm = TRUE)) {
  method <- match.arg(method)
  seasons <- sort(unique(df_joined$season))
  stops <- seasons[seasons >= first_train_end & seasons < last_test_season]

  out <- vector("list", length(stops))
  j <- 0L
  for (te in stops) {
    preds <- switch(
      method,
      equal = predict_equal_k(df_joined %>% dplyr::filter(season <= te + 1), stat, k),
      exp   = predict_exp_k  (df_joined %>% dplyr::filter(season <= te + 1), stat, k, alpha),
      lm    = fit_and_predict_reg_k(df_joined, stat, k, train_end_season = te)
    )
    if (nrow(preds) == 0) next
    preds <- preds %>% dplyr::filter(season == te + 1)
    if (nrow(preds)) { j <- j + 1L; out[[j]] <- preds %>% dplyr::mutate(train_end = te) }
  }
  if (j == 0L) return(tibble::tibble())
  dplyr::bind_rows(out[1:j])
}

# --- 5) Metrics (adds scale-free rel_rmse / rel_mae) ---
compute_metrics <- function(df, pred_col = "pred") {
  if (nrow(df) == 0) {
    return(tibble::tibble(
      n = 0, rmse = NA_real_, mae = NA_real_, bias = NA_real_,
      sse = NA_real_, sst = NA_real_, r2 = NA_real_,
      sd_actual = NA_real_, rel_rmse = NA_real_, rel_mae = NA_real_
    ))
  }
  err  <- df[[pred_col]] - df$actual
  rmse <- sqrt(mean(err^2, na.rm = TRUE))
  mae  <- mean(abs(err), na.rm = TRUE)
  bias <- mean(err,       na.rm = TRUE)
  sse  <- sum((df$actual - df[[pred_col]])^2, na.rm = TRUE)
  sst  <- sum((df$actual - mean(df$actual, na.rm = TRUE))^2, na.rm = TRUE)
  r2   <- if (!is.finite(sst) || sst <= 0) NA_real_ else (1 - sse/sst)
  sd_actual <- stats::sd(df$actual, na.rm = TRUE)
  rel_rmse  <- if (!is.finite(sd_actual) || sd_actual == 0) NA_real_ else rmse / sd_actual
  rel_mae   <- if (!is.finite(sd_actual) || sd_actual == 0) NA_real_ else mae  / sd_actual
  tibble::tibble(n = nrow(df), rmse, mae, bias, sse, sst, r2, sd_actual, rel_rmse, rel_mae)
}

# --- 6) Wrappers to evaluate all k/alpha/method combos for a stat ---
evaluate_equal <- function(stat, k) {
  res <- evaluate_rolling(joined, stat, k, method = "equal", first_train_end = first_train_end)
  if (nrow(res) == 0) return(NULL)
  compute_metrics(dplyr::rename(res, pred = pred_equal)) %>%
    dplyr::mutate(method = "equal", stat = stat, k = k, alpha = NA_real_)
}

evaluate_exp <- function(stat, k, alpha) {
  res <- evaluate_rolling(joined, stat, k, method = "exp", alpha = alpha, first_train_end = first_train_end)
  if (nrow(res) == 0) return(NULL)
  compute_metrics(dplyr::rename(res, pred = pred_exp)) %>%
    dplyr::mutate(method = "exp", stat = stat, k = k, alpha = alpha)
}

evaluate_lm <- function(stat, k) {
  res <- evaluate_rolling(joined, stat, k, method = "lm", first_train_end = first_train_end)
  if (nrow(res) == 0) return(NULL)
  compute_metrics(dplyr::rename(res, pred = pred_lm)) %>%
    dplyr::mutate(method = "lm", stat = stat, k = k, alpha = NA_real_)
}

compare_methods_for_stat <- function(stat) {
  eq <- purrr::map_dfr(k_grid, ~ evaluate_equal(stat, .x))
  ex <- purrr::map_dfr(k_grid, ~ purrr::map_dfr(alpha_grid, function(a) evaluate_exp(stat, .x, a)))
  lm <- purrr::map_dfr(k_grid, ~ evaluate_lm(stat, .x))
  dplyr::bind_rows(eq, ex, lm) %>%
    dplyr::arrange(rel_rmse) %>%
    dplyr::mutate(rank = dplyr::row_number())
}

# --- 7) Recompute all_results and winners ---
all_results <- purrr::map_dfr(stats_vec, compare_methods_for_stat)

winners <- all_results %>%
  dplyr::group_by(stat) %>%
  dplyr::arrange(rel_rmse, .by_group = TRUE) %>%
  dplyr::mutate(rel_rmse_next_best = dplyr::lead(rel_rmse)) %>%
  dplyr::slice(1) %>%
  dplyr::ungroup() %>%
  dplyr::transmute(
    stat,
    best_method = method,
    best_k      = k,
    best_alpha  = alpha,
    rmse, mae, r2, rel_rmse, rel_mae,
    margin_vs_next = rel_rmse_next_best - rel_rmse
  )

```


```{r predict 2026 per-36 with graceful fallback and year over year deltas}
# Experience year from career "from"
career <- read_data(params$career_csv) %>%
janitor::clean_names() %>%
dplyr::select(player_id, from) %>%
dplyr::mutate(from = as.integer(from))

# Experience-binned YoY deltas
df_exp <- df_clean %>%
  select(player_id, season, mp, all_of(stats_vec)) %>%
  left_join(career, by = "player_id") %>%
  mutate(exp_year_t = ifelse(!is.na(from), season - from + 1L, NA_integer_))

lag_tbl <- df_exp %>%
  select(player_id, season, all_of(stats_vec)) %>%
  mutate(season = season + 1L) %>%
  rename_with(~ paste0(.x, "_lag1"), all_of(stats_vec))

yoy <- df_exp %>%
  inner_join(lag_tbl, by = c("player_id","season")) %>%
  mutate(across(all_of(stats_vec),
                ~ .x - get(paste0(cur_column(), "_lag1")),
                .names = "{.col}_delta"))

yoy_long <- yoy %>%
  select(player_id, season, exp_year_t, ends_with("_delta")) %>%
  pivot_longer(cols = ends_with("_delta"), names_to = "stat", values_to = "delta") %>%
  mutate(stat = str_remove(stat, "_delta$"), exp_year = exp_year_t) %>%
  filter(!is.na(delta), !is.na(exp_year), exp_year >= 2)

exp_breaks <- c(2, 4, 7, 11, 16, Inf)
exp_labels <- c("2–3", "4–6", "7–10", "11–15", "16+")
bin_exp <- function(exp_year) cut(exp_year, breaks = exp_breaks, labels = exp_labels, right = FALSE)

yoy_binned <- yoy_long %>%
  mutate(exp_bin = bin_exp(exp_year)) %>%
  group_by(stat, exp_bin) %>%
  summarise(n_pairs = n(), mean_delta = mean(delta, na.rm = TRUE), .groups = "drop")

delta_lookup <- yoy_binned %>% select(stat, exp_bin, mean_delta)

# Build features for T_target
make_features_for_target <- function(df_base, T, k_max = 5, stats = stats_vec) {
  feat <- df_base %>% filter(season == T - 1) %>% distinct(player_id) %>% mutate(season = T)
  for (i in 1:k_max) {
    lag_i <- df_base %>% filter(season == T - i) %>% select(player_id, all_of(stats))
    names(lag_i)[-1] <- paste0(names(lag_i)[-1], "_L", i)
    feat <- feat %>% left_join(lag_i, by = "player_id")
  }
  feat
}

predict_equal_k_on_features <- function(feat, stat, k) {
  lag_cols <- paste0(stat, "_L", 1:k)
  feat %>%
    filter(if_all(all_of(lag_cols), ~ !is.na(.))) %>%
    mutate(pred = rowMeans(across(all_of(lag_cols)), na.rm = FALSE)) %>%
    transmute(player_id, season, stat = stat, pred, method = "equal", k_used = k, alpha = NA_real_)
}

predict_exp_k_on_features <- function(feat, stat, k, alpha = 0.7) {
  lag_cols <- paste0(stat, "_L", 1:k)
  w <- alpha * (1 - alpha)^(0:(k-1)); w <- w / sum(w)
  feat %>%
    filter(if_all(all_of(lag_cols), ~ !is.na(.))) %>%
    mutate(pred = as.numeric(as.matrix(select(., all_of(lag_cols))) %*% w)) %>%
    transmute(player_id, season, stat = stat, pred, method = "exp", k_used = k, alpha = alpha)
}

fit_predict_lm_k_for_future <- function(df_hist, featT, stat, k, T) {
  base_hist <- df_hist %>% select(player_id, season, all_of(stats_vec))
  lagged_list <- lapply(1:5, function(i) {
    base_hist %>% rename_with(~ paste0(.x, "_L", i), all_of(stats_vec)) %>%
      mutate(season = season + i)
  })
  joined_hist <- Reduce(function(x, y) left_join(x, y, by = c("player_id","season")), lagged_list, init = base_hist)
  lag_cols <- paste0(stat, "_L", 1:k)
  train <- joined_hist %>%
    select(player_id, season, all_of(stat), all_of(lag_cols)) %>%
    filter(season <= T - 1) %>% tidyr::drop_na()
  if (nrow(train) == 0) return(tibble(player_id=character(),season=integer(),stat=character(),
                                      pred=double(),method=character(),k_used=integer(),alpha=double()))
  form <- as.formula(paste(stat, "~", paste(lag_cols, collapse = " + ")))
  fit  <- lm(form, data = train)
  featT %>%
    filter(if_all(all_of(lag_cols), ~ !is.na(.))) %>%
    mutate(pred = predict(fit, newdata = .)) %>%
    transmute(player_id, season, stat = stat, pred, method = "lm", k_used = k, alpha = NA_real_)
}

# Choose best method per stat (from winners) and predict for 2026 with k fallback
featT <- make_features_for_target(
  df_clean %>% select(player_id, season, all_of(stats_vec)),
  T = params$target_season, k_max = 5, stats = stats_vec
)

# You should already have `winners` from Step 3; if not, stop here.
stopifnot(exists("winners"))

preds_2026_base <- purrr::map_dfr(seq_len(nrow(winners)), function(i) {
  row <- winners[i, ]
  stat <- row$stat
  meth <- row$best_method
  k_top <- as.integer(row$best_k)
  alpha <- row$best_alpha
  ks <- k_top:1
  bind_rows(lapply(ks, function(kk) {
    if (meth == "equal") {
      predict_equal_k_on_features(featT, stat, kk)
    } else if (meth == "exp") {
      predict_exp_k_on_features(featT, stat, kk, ifelse(is.na(alpha), 0.7, alpha))
    } else {
      fit_predict_lm_k_for_future(df_clean, featT, stat, kk, params$target_season)
    }
  })) %>%
    arrange(player_id, dplyr::desc(k_used)) %>%
    group_by(player_id) %>%
    slice_head(n = 1) %>%
    ungroup()
})

# Ensure 9 stats per player with L1..L5 fallback
features_2026 <- featT
eligible_ids <- features_2026 %>% distinct(player_id)
grid_all <- eligible_ids %>% tidyr::crossing(stat = stats_vec) %>% mutate(season = params$target_season)
preds_joined <- grid_all %>% left_join(preds_2026_base, by = c("player_id","season","stat"))

if (any(is.na(preds_joined$pred))) {
  cand <- preds_joined %>% filter(is.na(pred)) %>% left_join(features_2026, by = c("player_id","season"))
  latest_non_na <- function(df, cols) { out <- rep(NA_real_, nrow(df)); for (i in seq_along(cols)) { v <- df[[cols[i]]]; idx <- is.na(out) & !is.na(v); out[idx] <- v[idx]; if (all(!is.na(out))) break }; out }
  which_lag_used <- function(df, cols) { out <- rep(NA_integer_, nrow(df)); for (i in seq_along(cols)) { v <- df[[cols[i]]]; idx <- is.na(out) & !is.na(v); out[idx] <- i; if (all(!is.na(out))) break }; out }
  fb_list <- lapply(stats_vec, function(s) {
    sub <- cand %>% filter(stat == s); if (nrow(sub) == 0) return(NULL)
    lag_cols <- paste0(s, "_L", 1:5); lag_cols <- lag_cols[lag_cols %in% names(sub)]
    tibble(player_id = sub$player_id, season = sub$season, stat = s,
           pred = latest_non_na(sub, lag_cols), method = "equal", k_used = which_lag_used(sub, lag_cols), alpha = NA_real_) %>%
      filter(!is.na(pred))
  })
  fb_any <- bind_rows(fb_list)
  preds_2026_base <- preds_joined %>%
    select(player_id, season, stat, pred, method, k_used, alpha) %>%
    bind_rows(fb_any) %>%
    arrange(player_id, stat, dplyr::desc(k_used)) %>%
    group_by(player_id, season, stat) %>%
    slice_head(n = 1) %>%
    ungroup()
}

# Add YoY bin delta; clip percentages; attach labels
is_pct_stat <- function(s) s %in% c("fg_percent","ft_percent")

exp_2026 <- eligible_ids %>%
  mutate(season = params$target_season) %>%
  left_join(career %>% select(player_id, from), by = "player_id") %>%
  mutate(exp_year_2026 = ifelse(!is.na(from), season - from + 1L, NA_integer_),
         exp_bin = bin_exp(exp_year_2026))

preds_2026_final <- preds_2026_base %>%
  left_join(exp_2026 %>% select(player_id, season, exp_year_2026, exp_bin), by = c("player_id","season")) %>%
  left_join(delta_lookup, by = c("stat","exp_bin")) %>%
  mutate(delta_exp = ifelse(is.na(mean_delta), 0, mean_delta),
         pred_adj_raw = pred + delta_exp,
         pred_adj = ifelse(is_pct_stat(stat), pmax(0, pmin(1, pred_adj_raw)), pred_adj_raw)) %>%
  left_join(df_clean %>% filter(season == params$target_season - 1) %>% select(player_id, player, pos), by = "player_id") %>%
  select(player_id, player, pos, season, stat, pred_base = pred, delta_exp, pred_adj, method, k_used, alpha, exp_year_2026, exp_bin) %>%
  group_by(player_id, season, stat) %>% summarise(across(everything(), ~ dplyr::first(.x)), .groups = "drop")

preds_2026_wide <- preds_2026_final %>%
  select(player_id, player, pos, season, stat, pred_adj) %>%
  tidyr::pivot_wider(names_from = stat, values_from = pred_adj)

# Show a sample
preds_2026_final %>% arrange(player) %>% dplyr::slice_head(n = 15)
```

```{r Scatter Plot}
# Helper: pretty label for a stat key
lab_for_stat <- function(stat_key) {
  if (stat_key %in% names(stat_labs)) stat_labs[[stat_key]] else stat_key
}

# ---- 1) Plot function for a single stat ----
plot_best_rel_rmse_by_method <- function(target_stat, save = FALSE, out_dir = "output", width = 6, height = 4) {
  stopifnot(all(c("stat","k","method","rel_rmse") %in% names(all_results)))

  df_best <- all_results %>%
    filter(stat == target_stat, is.finite(rel_rmse)) %>%
    group_by(method) %>%
    summarise(
      best_rel_rmse = min(rel_rmse, na.rm = TRUE),
      best_k        = k[which.min(rel_rmse)],
      .groups = "drop"
    ) %>%
    mutate(
      method   = factor(method, levels = c("equal","exp","lm")),
      lab_k    = paste0("L", best_k),
      lab_rmse = percent(best_rel_rmse, accuracy = 1)
    )

    # If a method is missing (edge case), fill with NA bar so axes still compute
    all_methods <- tibble(method = factor(c("equal","exp","lm"), levels = c("equal","exp","lm")))
    df_best <- all_methods %>% left_join(df_best, by = "method")

    # Axis band (reversed):
    # - bottom = ceil(worst to next 0.1)
    # - top    = round(best to nearest 0.1), with a tiny safety gap if needed
    worst    <- max(df_best$best_rel_rmse, na.rm = TRUE)
    best     <- min(df_best$best_rel_rmse, na.rm = TRUE)
    y_bottom <- ceiling(worst * 10) / 10
    y_top    <- round(best   * 10) / 10
    if (!is.finite(y_top) || y_top >= y_bottom) y_top <- max(best - 0.02, 0)

    title_txt <- paste0(lab_for_stat(target_stat), " — Best Relative RMSE by Method")

    p <- ggplot(df_best, aes(x = method)) +
      # thick segment from axis bottom up to each method's RMSE
      geom_segment(aes(xend = method, y = y_bottom, yend = best_rel_rmse, color = method),
                   linewidth = 10, lineend = "butt", show.legend = FALSE, na.rm = TRUE) +
      geom_point(aes(y = best_rel_rmse, color = method), size = 2.2, show.legend = FALSE, na.rm = TRUE) +
      geom_text(aes(y = best_rel_rmse, label = paste0(lab_k, " • ", lab_rmse)),
                vjust = -0.6, size = 4, fontface = "bold", na.rm = TRUE) +
      scale_y_reverse(
        limits = c(y_bottom, y_top),
        labels = percent_format(accuracy = 1),
        expand = expansion(mult = c(0, .10))
      ) +
      labs(
        title = title_txt,
        subtitle = "Lower RMSE = longer bar (axis flipped). Label shows winning lookback and rel. RMSE.",
        x = NULL,
        y = "Relative RMSE (RMSE / SD of actual; ↓ better)"
      ) +
      theme_minimal(base_size = 12) +
      theme(
        panel.grid.major.x = element_blank(),
        plot.title.position = "plot"
      )

    if (isTRUE(save)) {
      if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
      file_safe <- str_replace_all(target_stat, "[^A-Za-z0-9_]+", "_")
      out_path <- file.path(out_dir, paste0("relRMSE_", file_safe, ".png"))
      ggsave(out_path, p, width = width, height = height, dpi = 150)
      message("Saved: ", out_path)
    }

    return(p)
}

# ---- 2) Make one for PTS/36 (interactive test) ----
#plot_best_rel_rmse_by_method("pts_per_36_min")

# --- Display & save one figure per stat ---
# (Each plot will appear in the HTML and also be written to /output)
invisible(lapply(stats_vec, function(s) {
  p <- plot_best_rel_rmse_by_method(s, save = TRUE, out_dir = "output")
  print(p)  # ensures the plot is displayed in the knitted HTML
}))
```